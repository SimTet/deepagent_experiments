"""Requirements engineering tools for agile methodology."""

import json
import re
from datetime import datetime
from pathlib import Path
from typing import Any, Literal, Optional

from langchain_core.tools import tool

# Output directory for requirements
OUTPUT_DIR = Path(__file__).parent.parent / "output"
OUTPUT_DIR.mkdir(exist_ok=True)


def sanitize_filename(text: str) -> str:
    """Convert text to valid filename."""
    clean = re.sub(r"[^\w\s-]", "", text.lower())
    return re.sub(r"[\s-]+", "_", clean)[:50]


def get_next_id(prefix: str) -> str:
    """Get next available ID for epics or stories."""
    existing = list(OUTPUT_DIR.glob(f"{prefix}-*.md"))
    if not existing:
        return f"{prefix}-001"

    ids = []
    for f in existing:
        match = re.search(rf"{prefix}-(\d+)", f.stem)
        if match:
            ids.append(int(match.group(1)))

    next_num = max(ids) + 1 if ids else 1
    return f"{prefix}-{next_num:03d}"


def load_requirements_index() -> dict[str, Any]:
    """Load or create the requirements index."""
    index_path = OUTPUT_DIR / "requirements_index.json"
    if index_path.exists():
        return json.loads(index_path.read_text())
    return {"epics": {}, "stories": {}, "created": datetime.now().isoformat()}


def save_requirements_index(index: dict[str, Any]) -> None:
    """Save the requirements index."""
    index_path = OUTPUT_DIR / "requirements_index.json"
    index["updated"] = datetime.now().isoformat()
    index_path.write_text(json.dumps(index, indent=2))


@tool(parse_docstring=True)
def create_epic(
    title: str,
    description: str,
    business_value: str,
    acceptance_criteria: list[str],
    priority: Literal["High", "Medium", "Low"] = "Medium",
    estimated_effort: Optional[str] = None,
    stakeholders: Optional[list[str]] = None,
    dependencies: Optional[list[str]] = None,
) -> str:
    """Create a new Epic requirement document following agile methodology.

    An Epic is a large body of work that can be broken down into smaller
    user stories. Use this to capture high-level business requirements.

    Args:
        title: Clear, concise epic title describing the capability.
        description: Detailed description of the epic, including context and scope.
        business_value: Why this epic matters to the business.
        acceptance_criteria: List of high-level criteria that define when the epic is complete.
        priority: Business priority - 'High', 'Medium', or 'Low'.
        estimated_effort: Optional T-shirt size estimate (XS, S, M, L, XL).
        stakeholders: Optional list of key stakeholders or teams involved.
        dependencies: Optional list of other epics or external dependencies.

    Returns:
        Success message with epic ID and file path.
    """
    epic_id = get_next_id("EPIC")
    filename = f"{epic_id}_{sanitize_filename(title)}.md"
    filepath = OUTPUT_DIR / filename

    # Build epic document
    content = f"""# {epic_id}: {title}

**Priority:** {priority}
**Status:** Draft
**Created:** {datetime.now().strftime('%Y-%m-%d')}
"""

    if estimated_effort:
        content += f"**Estimated Effort:** {estimated_effort}\n"

    content += f"""
## Description

{description}

## Business Value

{business_value}

## Acceptance Criteria

"""
    for i, criterion in enumerate(acceptance_criteria, 1):
        content += f"{i}. {criterion}\n"

    if stakeholders:
        content += "\n## Stakeholders\n\n"
        for stakeholder in stakeholders:
            content += f"- {stakeholder}\n"

    if dependencies:
        content += "\n## Dependencies\n\n"
        for dep in dependencies:
            content += f"- {dep}\n"

    content += """
## User Stories

_Stories will be linked here as they are created._

---
*Generated by Requirements Agent*
"""

    filepath.write_text(content)

    # Update index
    index = load_requirements_index()
    index["epics"][epic_id] = {
        "title": title,
        "priority": priority,
        "status": "Draft",
        "file": filename,
        "stories": [],
        "created": datetime.now().isoformat(),
    }
    save_requirements_index(index)

    return f"Epic created successfully!\n\n**ID:** {epic_id}\n**File:** {filepath}\n**Title:** {title}"


@tool(parse_docstring=True)
def create_user_story(
    epic_id: str,
    title: str,
    as_a: str,
    i_want: str,
    so_that: str,
    acceptance_criteria: list[str],
    priority: Literal["High", "Medium", "Low"] = "Medium",
    story_points: Optional[int] = None,
    technical_notes: Optional[str] = None,
    ui_ux_considerations: Optional[str] = None,
) -> str:
    """Create a user story linked to an existing epic.

    User stories follow the format: "As a [persona], I want [feature],
    so that [benefit]." This captures user needs in a structured way.

    Args:
        epic_id: Parent epic ID (e.g., 'EPIC-001'). Must exist.
        title: Brief story title for reference.
        as_a: The user persona or role (e.g., "data analyst", "admin user").
        i_want: The desired functionality or feature.
        so_that: The benefit or value gained from this feature.
        acceptance_criteria: List of specific, testable criteria (use Given/When/Then format).
        priority: Story priority within the epic.
        story_points: Optional story point estimate (1, 2, 3, 5, 8, 13).
        technical_notes: Optional implementation considerations.
        ui_ux_considerations: Optional UI/UX notes and design requirements.

    Returns:
        Success message with story ID and file path.
    """
    # Verify epic exists
    index = load_requirements_index()
    if epic_id not in index.get("epics", {}):
        return f"Error: Epic '{epic_id}' not found. Please create the epic first or check the ID."

    story_id = get_next_id("STORY")
    filename = f"{story_id}_{sanitize_filename(title)}.md"
    filepath = OUTPUT_DIR / filename

    content = f"""# {story_id}: {title}

**Epic:** [{epic_id}]({index['epics'][epic_id]['file']})
**Priority:** {priority}
**Status:** Backlog
**Created:** {datetime.now().strftime('%Y-%m-%d')}
"""

    if story_points:
        content += f"**Story Points:** {story_points}\n"

    content += f"""
## User Story

**As a** {as_a},
**I want** {i_want},
**So that** {so_that}.

## Acceptance Criteria

"""
    for i, criterion in enumerate(acceptance_criteria, 1):
        content += f"{i}. {criterion}\n"

    if technical_notes:
        content += f"\n## Technical Notes\n\n{technical_notes}\n"

    if ui_ux_considerations:
        content += f"\n## UI/UX Considerations\n\n{ui_ux_considerations}\n"

    content += """
## Tasks

- [ ] Implementation
- [ ] Testing
- [ ] Documentation

---
*Generated by Requirements Agent*
"""

    filepath.write_text(content)

    # Update index
    index["stories"][story_id] = {
        "title": title,
        "epic_id": epic_id,
        "priority": priority,
        "status": "Backlog",
        "file": filename,
        "story_points": story_points,
        "created": datetime.now().isoformat(),
    }
    index["epics"][epic_id]["stories"].append(story_id)
    save_requirements_index(index)

    return f"User Story created successfully!\n\n**ID:** {story_id}\n**Epic:** {epic_id}\n**File:** {filepath}\n**Title:** {title}"


@tool(parse_docstring=True)
def list_requirements(
    filter_type: Optional[Literal["epics", "stories", "all"]] = "all",
    filter_epic: Optional[str] = None,
    filter_priority: Optional[Literal["High", "Medium", "Low"]] = None,
) -> str:
    """List existing requirements (epics and/or user stories).

    Use this to see what requirements have already been created and
    understand the current project structure.

    Args:
        filter_type: What to list - 'epics', 'stories', or 'all'.
        filter_epic: Optional epic ID to show only stories for that epic.
        filter_priority: Optional priority filter.

    Returns:
        Formatted list of requirements with IDs, titles, and status.
    """
    index = load_requirements_index()

    result = "## Requirements Overview\n\n"

    if filter_type in ["epics", "all"]:
        result += "### Epics\n\n"
        epics = index.get("epics", {})
        if not epics:
            result += "_No epics created yet._\n\n"
        else:
            for epic_id, epic in epics.items():
                if filter_priority and epic.get("priority") != filter_priority:
                    continue
                story_count = len(epic.get("stories", []))
                result += f"- **{epic_id}**: {epic['title']}\n"
                result += f"  - Priority: {epic['priority']} | Status: {epic['status']} | Stories: {story_count}\n"
            result += "\n"

    if filter_type in ["stories", "all"]:
        result += "### User Stories\n\n"
        stories = index.get("stories", {})

        if filter_epic:
            stories = {k: v for k, v in stories.items() if v.get("epic_id") == filter_epic}

        if not stories:
            result += "_No stories created yet._\n\n"
        else:
            for story_id, story in stories.items():
                if filter_priority and story.get("priority") != filter_priority:
                    continue
                points = f" ({story['story_points']} pts)" if story.get("story_points") else ""
                result += f"- **{story_id}**: {story['title']}{points}\n"
                result += f"  - Epic: {story['epic_id']} | Priority: {story['priority']} | Status: {story['status']}\n"

    return result


@tool(parse_docstring=True)
def refine_requirement(
    requirement_id: str,
    updates: dict[str, Any],
    add_notes: Optional[str] = None,
) -> str:
    """Update or refine an existing epic or user story.

    Use this to modify requirements based on stakeholder feedback or
    additional analysis.

    Args:
        requirement_id: The ID of the requirement to update (e.g., 'EPIC-001' or 'STORY-002').
        updates: Dictionary of fields to update. For epics use priority/status. For stories use priority/status/story_points.
        add_notes: Optional additional notes to append to the document.

    Returns:
        Success message confirming the updates applied.
    """
    index = load_requirements_index()

    is_epic = requirement_id.startswith("EPIC")
    is_story = requirement_id.startswith("STORY")

    if is_epic and requirement_id not in index.get("epics", {}):
        return f"Error: Epic '{requirement_id}' not found."
    if is_story and requirement_id not in index.get("stories", {}):
        return f"Error: Story '{requirement_id}' not found."

    # Get the requirement info
    if is_epic:
        req_info = index["epics"][requirement_id]
    else:
        req_info = index["stories"][requirement_id]

    filepath = OUTPUT_DIR / req_info["file"]

    if not filepath.exists():
        return f"Error: File for {requirement_id} not found at {filepath}"

    content = filepath.read_text()

    # Apply updates
    applied = []

    for field, value in updates.items():
        if field == "priority":
            content = re.sub(r"\*\*Priority:\*\* \w+", f"**Priority:** {value}", content)
            req_info["priority"] = value
            applied.append(f"priority -> {value}")

        elif field == "status":
            content = re.sub(r"\*\*Status:\*\* \w+", f"**Status:** {value}", content)
            req_info["status"] = value
            applied.append(f"status -> {value}")

        elif field == "story_points" and is_story:
            if "**Story Points:**" in content:
                content = re.sub(r"\*\*Story Points:\*\* \d+", f"**Story Points:** {value}", content)
            else:
                # Add story points after status
                content = content.replace(
                    f"**Status:** {req_info.get('status', 'Backlog')}",
                    f"**Status:** {req_info.get('status', 'Backlog')}\n**Story Points:** {value}",
                )
            req_info["story_points"] = value
            applied.append(f"story_points -> {value}")

    # Add notes if provided
    if add_notes:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        notes_section = f"\n## Refinement Notes\n\n**[{timestamp}]** {add_notes}\n"

        # Insert before the footer
        content = content.replace(
            "---\n*Generated by Requirements Agent*",
            f"{notes_section}\n---\n*Generated by Requirements Agent*",
        )
        applied.append("notes added")

    # Save updates
    filepath.write_text(content)
    save_requirements_index(index)

    return f"Requirement {requirement_id} updated successfully!\n\nChanges applied:\n" + "\n".join(
        f"- {a}" for a in applied
    )


@tool(parse_docstring=True)
def generate_requirements_summary() -> str:
    """Generate a comprehensive summary report of all requirements.

    Creates an overview document showing all epics, their stories,
    status distribution, and coverage metrics.

    Returns:
        Summary report as formatted markdown.
    """
    index = load_requirements_index()

    epics = index.get("epics", {})
    stories = index.get("stories", {})

    # Calculate metrics
    total_epics = len(epics)
    total_stories = len(stories)

    priority_dist = {"High": 0, "Medium": 0, "Low": 0}
    status_dist: dict[str, int] = {}
    total_points = 0
    estimated_points = 0

    for epic in epics.values():
        priority_dist[epic.get("priority", "Medium")] += 1

    for story in stories.values():
        priority_dist[story.get("priority", "Medium")] += 1
        status = story.get("status", "Backlog")
        status_dist[status] = status_dist.get(status, 0) + 1
        if story.get("story_points"):
            total_points += 1
            estimated_points += story["story_points"]

    # Build report
    report = f"""# Requirements Summary Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}

## Overview

| Metric | Count |
|--------|-------|
| Total Epics | {total_epics} |
| Total User Stories | {total_stories} |
| Stories with Estimates | {total_points} |
| Total Story Points | {estimated_points} |

## Priority Distribution

| Priority | Count |
|----------|-------|
| High | {priority_dist['High']} |
| Medium | {priority_dist['Medium']} |
| Low | {priority_dist['Low']} |

## Status Distribution

| Status | Count |
|--------|-------|
"""
    for status, count in sorted(status_dist.items()):
        report += f"| {status} | {count} |\n"

    report += "\n## Epics Breakdown\n\n"

    for epic_id, epic in epics.items():
        epic_stories = [s for s in stories.values() if s.get("epic_id") == epic_id]
        story_points = sum(s.get("story_points", 0) for s in epic_stories)

        report += f"""### {epic_id}: {epic['title']}

- **Priority:** {epic['priority']}
- **Status:** {epic['status']}
- **Stories:** {len(epic_stories)}
- **Total Story Points:** {story_points}

"""

    # Save summary
    summary_path = OUTPUT_DIR / "REQUIREMENTS_SUMMARY.md"
    summary_path.write_text(report)

    return f"Summary report generated!\n\n**File:** {summary_path}\n\n{report}"


@tool(parse_docstring=True)
def interview_stakeholder(question: str, context: Optional[str] = None) -> str:
    """Record a stakeholder interview question for requirements elicitation.

    Use this tool to guide an interactive requirements gathering session.
    The tool will format the question and wait for user response.

    Args:
        question: The question to ask the stakeholder about their requirements.
        context: Optional context about why this question is being asked.

    Returns:
        Formatted question prompt for the stakeholder.
    """
    result = "\n## Stakeholder Question\n\n"

    if context:
        result += f"*Context: {context}*\n\n"

    result += f"**Question:** {question}\n\n"
    result += "*Please provide your response, and I'll incorporate it into the requirements.*"

    return result
